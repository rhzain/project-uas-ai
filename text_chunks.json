["OS Introduction: Definition and Role: Program/software controlling application execution.\nOS Introduction: Definition and Role: Interface between user and hardware.\nOS Introduction: Definition and Role: Provides environment for users to run programs.\nOS Introduction: Objectives: Convenience (makes computer system easier to use).\nOS Introduction: Objectives: Efficiency (allows efficient use of computer system resources).\nOS Introduction: Computer System Components: Relation between Hardware, Operating System, System Programs, and Application Programs.\nOS Introduction: OS Services: Providing user interface.\nOS Introduction: OS Services: Providing program execution.\nOS Introduction: OS Services: Providing I/O operations.\nOS Introduction: OS Services: Providing file-system manipulation.\nOS Introduction: OS Services: Providing system communications / networking.\nOS Introduction: OS Services: Error detection.\nOS Introduction: OS Services: Resource Sharing.\nOS Introduction: OS Services:", "Security.\nOS Introduction: OS Services: Accounting system.\nOS Introduction: Basic Functions: As 'Extended machine' or 'virtual machine'.\nOS Introduction: Basic Functions: Hides hardware complexities like disk access, interrupts, memory management.\nOS Introduction: Basic Functions: As 'Resources manager'.\nOS Introduction: Basic Functions: Manages computer resources like processor, memory, timer, disk, etc.\nOS Introduction: History: Generation I (1945-1955): Vacuum tube, plugboard, machine language, no OS.\nOS Introduction: History: Generation II (1955-1965): Transistor, batch system, punch card, FORTRAN/Assembly, tape drive, early OS (FMS, IBSYS), off-line printing.\nOS Introduction: History: Generation III (1965-1980): IC, multi programming (e.g., IBM System/360 with OS/360), disk usage, Spooling, MULTICS, origins of UNIX.\nOS Introduction: History: Generation IV (1980 onwards): PC, LSI/VLSI, MS DOS, UNIX, IBM PC, CISC/RISC processors, Network OS, Distributed OS, Uni/Multi processor", "systems, Families like Microsoft Windows, UNIX, Mac OS, Client Server Computing, OS for Smartphones.\nOS Introduction: Types of OS on Computers: Microsoft Windows family, Unix family, Mac OS.\nOS Introduction: Types of OS by Platform: Microcomputers, Mainframe, Supercomputer, Workstation/server, Networking, PDA, Smartphone.\nOS Introduction: Types of OS: Various Unix versions (AIX, A/UX, BSD, HP/UX, etc.).\nOS Introduction: Types of OS: Mobile OS (Symbian, Windows Mobile, Mobile Linux, BlackBerry, Palm, Java, Android, IOS).\nOS Introduction: Types of Computer Operation: Single Program Operation (mono programming).\nOS Introduction: Types of Computer Operation: Batch Processing.\nOS Introduction: Types of Computer Operation: Multi programming/multi tasking.\nOS Introduction: Types of Computer Operation: Multi access.\nOS Introduction: Ideal OS Structure Components: Nucleus.\nOS Introduction: Ideal OS Structure Components: Memory management.\nOS Introduction: Ideal OS Structure Components: I/O", "control.\nOS Introduction: Ideal OS Structure Components: Backing Store management.\nOS Introduction: Ideal OS Structure Components: Resource Allocation & Scheduling.\nOS Introduction: Ideal OS Structure Components: Protection.\n\nOS System Components: Process, Main Memory, I/O, File.\nOS Services Details: Programmer support.\nOS Services Details: Program Execution.\nOS Services Details: I/O Operations.\nOS Services Details: File Manipulation.\nOS Services Details: Communication.\nOS Services Details: Error detection.\nOS System Call: Definition: Extended instruction, API.\nOS System Call: Position: Between kernel and executable program.\nOS System Call: Categories: Process Control.\nOS System Call: Categories: File Manipulation.\nOS System Call: Categories: Device Manipulation.\nOS System Call: Categories: Environment Information.\nOS System Call: Categories: Communication.\nOS Communication Models: Message-passing model.\nOS Communication Models: Shared-memory model.\nOS System Programs: File", "manipulation.\nOS System Programs: Status Information.\nOS System Programs: File Modification.\nOS System Programs: Programming Language support.\nOS System Programs: Program Execution.\nOS System Programs: Communication.\nOS System Programs: Application programs.\nOS Structures: Simple Structure: Lack of structure, limited.\nOS Structures: Simple Structure: Examples include Minix kernel, Qemu.\nOS Structures: Monolithic System: Simple structure with dual-mode.\nOS Structures: Monolithic System: Uses trap instruction for system calls.\nOS Structures: Monolithic System: Examples include Unix, Linux, MS-DOS.\nOS Structures: Layered System: Divided into layers.\nOS Structures: Layered System: Lower layers provide services to higher layers.\nOS Structures: Layered System: Hardware at bottom, user interface at top.\nOS Structures: Layered System: Examples include THE, MULTICS, VENUS, OS/2.\nOS Structures: Virtual Machines: Simulates a real machine for each user.\nOS Structures: Virtual Machines: Provides", "illusion of having their own computer.\nOS Structures: Virtual Machines: Examples include CP/CMS, VM/370, VMWare.\nOS Structures: Client-Server Model: Server provides services.\nOS Structures: Client-Server Model: Client requests services via messages.\n\nProcess Management: Concept of Process: Definition (Program in execution).\nProcess Management: Concept of Process: Components (Program Counter, registers, variables).\nProcess Management: Concept of Process: Resource needs (CPU time, memory, file, I/O).\nProcess Management: Concept of Process: OS Role (Manage processes, allocate resources).\nProcess Management: Concept of Process: Principles (Independent, One program at any instant).\nProcess Management: Process Models: Multiprogramming/Multitasking (Managing many processes on one processor, pseudoparallelism).\nProcess Management: Process Models: Multiprocessing (Managing many processes on a multiprocessor computer).\nProcess Management: Process Models: Distributed processing (Managing", "processes on dispersed computers).\nProcess Management: Process Status: New.\nProcess Management: Process Status: Running.\nProcess Management: Process Status: Waiting.\nProcess Management: Process Status: Ready.\nProcess Management: Process Status: Terminated.\nProcess Management: Process Status Transitions: Ready to Running.\nProcess Management: Process Status Transitions: Running to Blocked (Waiting).\nProcess Management: Process Status Transitions: Running to Ready.\nProcess Management: Process Status Transitions: Blocked (Waiting) to Ready.\nProcess Management: Process Control Block (PCB): Representation of a process.\nProcess Management: Process Control Block (PCB): Contains Process Status.\nProcess Management: Process Control Block (PCB): Contains Program Counter.\nProcess Management: Process Control Block (PCB): Contains CPU Registers.\nProcess Management: Process Control Block (PCB): Contains Scheduling Information.\nProcess Management: Process Control Block (PCB): Contains Memory", "Information.\nProcess Management: Process Control Block (PCB): Contains Accounting Information.\nProcess Management: Process Control Block (PCB): Contains I/O Status Information.\nProcess Management: CPU Switch: Saving and restoring process status.\nProcess Management: Process Scheduling Basics: Scheduling Queues (Job queue, Ready queue, Device queue).\nProcess Management: Process Scheduling Basics: Schedulers (Long-term scheduler).\nProcess Management: Process Scheduling Basics: Schedulers (Short-term scheduler / CPU scheduler).\nProcess Management: Process Scheduling Basics: Context Switch (Process of saving/restoring state during switching).\nProcess Management: Operations on Processes: Creation Steps: Giving identity.\nProcess Management: Operations on Processes: Creation Steps: Inserting into process list.\nProcess Management: Operations on Processes: Creation Steps: Setting priority.\nProcess Management: Operations on Processes: Creation Steps: Creating PCB.\nProcess Management: Operations", "on Processes: Creation Steps: Allocating resources.\nProcess Management: Operations on Processes: Events Causing Creation: New job submission.\nProcess Management: Operations on Processes: Events Causing Creation: User logon.\nProcess Management: Operations on Processes: Events Causing Creation: Application response to a need.\nProcess Management: Operations on Processes: Events Causing Creation: Process creating a child process.\nProcess Management: Operations on Processes: Parent-Child Relationship: Parent creates child.\nProcess Management: Operations on Processes: Parent-Child Relationship: Child can create more processes.\nProcess Management: Operations on Processes: Parent-Child Relationship: Resource sharing options between parent and child.\nProcess Management: Operations on Processes: Parent-Child Relationship: Execution options (parent waits or runs concurrently).\nProcess Management: Operations on Processes: Parent-Child Relationship: Address space options (child duplicates parent", "or has new program).\nProcess Management: Operations on Processes: Parent-Child Relationship: Examples UNIX FORK, MS-DOS process creation.\nProcess Management: Inter-Process Communication (IPC): Direct Communication: send/receive to/from specific process.\nProcess Management: Inter-Process Communication (IPC): Direct Communication: Connection properties.\nProcess Management: Inter-Process Communication (IPC): Indirect Communication: send/receive via mailbox.\nProcess Management: Inter-Process Communication (IPC): Indirect Communication: Connection properties.\nProcess Management: Inter-Process Communication (IPC): Indirect Communication: Mailbox operations (create, send/receive, destroy).\nProcess Management: Inter-Process Communication (IPC): Buffering: Temporary message storage.\nProcess Management: Inter-Process Communication (IPC): Buffering Implementation: Zero Capacity (sender waits for receiver).\nProcess Management: Inter-Process Communication (IPC): Buffering Implementation: Bounded", "Capacity (sender waits if buffer full).\nProcess Management: Inter-Process Communication (IPC): Buffering Implementation: Unbounded Capacity (sender never waits).\n\nCPU Scheduling: Basic Concepts: Multiprogramming/Multitasking role in CPU scheduling.\nCPU Scheduling: Basic Concepts: CPU-I/O Burst Cycle (process execution consists of a cycle of CPU execution and I/O wait).\nCPU Scheduling: Role of Short-term scheduler (CPU scheduler): Selects next process for CPU.\nCPU Scheduling: States Triggering Scheduling: Process switches from Running to Waiting state.\nCPU Scheduling: States Triggering Scheduling: Process switches from Running to Ready state.\nCPU Scheduling: States Triggering Scheduling: Process switches from Waiting to Ready state.\nCPU Scheduling: States Triggering Scheduling: Process Termination.\nCPU Scheduling: Preemptive Scheduling: CPU can be taken away from a running process.\nCPU Scheduling: Non-preemptive Scheduling: Process keeps CPU until it releases it (terminates or switches", "to waiting).\nCPU Scheduling: Criteria: CPU utilization (keep CPU as busy as possible).\nCPU Scheduling: Criteria: Throughput (number of processes completed per time unit).\nCPU Scheduling: Criteria: Turnaround time (time from submission to completion).\nCPU Scheduling: Criteria: Waiting time (time a process spends in the ready queue).\nCPU Scheduling: Criteria: Response time (time from submission until first response is produced).\nCPU Scheduling: Criteria: Fairness (all processes get fair share of CPU).\nCPU Scheduling: Criteria: Average Waiting Time (AWT) as a performance metric.\nCPU Scheduling: Algorithm: First-Come First-Served (FCFS): Processes served in order of request.\nCPU Scheduling: Algorithm: FCFS: Example calculation.\nCPU Scheduling: Algorithm: Shortest Job First (SJF): Process with smallest CPU burst served first.\nCPU Scheduling: Algorithm: SJF Schemes: Non-preemptive SJF.\nCPU Scheduling: Algorithm: SJF Schemes: Preemptive SJF (Shortest Remaining Time First - SRTF).\nCPU", "Scheduling: Algorithm: SJF: Examples and AWT calculation.\nCPU Scheduling: Algorithm: SJF Implementation: Difficulty in predicting next CPU burst time.\nCPU Scheduling: Algorithm: SJF Prediction: Using Exponential Average of previous CPU bursts.\nCPU Scheduling: Algorithm: Priority Scheduling: Based on integer priority (lower integer usually higher priority).\nCPU Scheduling: Algorithm: Priority Scheduling Schemes: Non-preemptive Priority.\nCPU Scheduling: Algorithm: Priority Scheduling Schemes: Preemptive Priority.\nCPU Scheduling: Algorithm: Priority Scheduling: Example calculation.\nCPU Scheduling: Algorithm: Round Robin (RR): Designed for time-sharing systems.\nCPU Scheduling: Algorithm: Round Robin (RR): Preemptive FCFS with a time quantum (time slice).\nCPU Scheduling: Algorithm: Round Robin (RR): Advantages (uniform time distribution).\nCPU Scheduling: Algorithm: Round Robin (RR): Disadvantages (overhead with very small quantum).\nCPU Scheduling: Algorithm: Round Robin (RR) Rules: Process", "runs for quantum or until burst finishes.\nCPU Scheduling: Algorithm: Round Robin (RR) Rules: If burst > quantum, process preempted and put at end of ready queue.\nCPU Scheduling: Algorithm: Round Robin (RR) Rules: If process blocks for I/O before quantum expires, it's moved to I/O queue.\nCPU Scheduling: Algorithm: Round Robin (RR): Example calculation of scheduling order.\nCPU Scheduling: Algorithm: Round Robin (RR): Turnaround Time (TA) = Waiting Time + Execution Time.\nCPU Scheduling: Algorithm: Round Robin (RR): TA relation to quantum size (larger quantum can lead to FCFS behavior, smaller quantum more context switches).\nCPU Scheduling: Algorithm: Round Robin (RR): Example calculation with Average Turnaround Time (ATAT)."]